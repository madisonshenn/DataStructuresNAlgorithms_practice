# Greedy Algorithm
making the locally optimal choice at each stage that approximate a globally optimal solution in a reasonable amount of time (by wikipedia.org)


#### 122. Best Time to Buy and Sell Stock II
You are given an integer array prices where prices[i] is the price of a given stock on
the ith day.
On each day, you may decide to buy and/or sell the stock. You can only hold at most
one share of the stock at any time. However, you can buy it then immediately sell it on
the same day.
Find and return the maximum profit you can achieve.
Example Input: prices = [7,1,5,3,6,4]
Output: 7
Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then
buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 +
3 = 7.
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        res = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i - 1]:
                res += prices[i] - prices[i - 1]
        return res
```
#### Follow up for 122. Best Time to Buy and Sell Stock II
You are given an integer array prices where prices[i] is the price of a given stock on the ith day.
On each day, you may decide to buy and/or sell the stock. However, you can buy it then immediately sell it on the same day.
Find and return the maximum profit you can achieve.
Example Input: prices = [1,2,10,9]
Output: 16
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        minheap = []        
        res = 0
        for i in prices:
            if minheap and k > minheap[0]:
                res += k - heapq.heappop(minheap)
                heapq.heappush(minheap, k)
            heapq.heappush(minheap, k)
        return res
```
#### Prime Movie Awards


#### 2578. Split With Minimum Sum
Given a positive integer num, split it into two non-negative integers num1 and num2 such that:
The concatenation of num1 and num2 is a permutation of num.

In other words, the sum of the number of occurrences of each digit in num1 and num2 is

equal to the number of occurrences of that digit in num.
num1 and num2 can contain leading zeros.
Return the minimum possible sum of num1 and num2.
Notes:
It is guaranteed that num does not contain any leading zeros.
The order of occurrence of the digits in num1 and num2 may differ from the order of occurrence
of num.
Example: Input: 4325 Output: 59 Explanation: 24 + 35 = 59
```
class Solution:
    def splitNum(self, num: int) -> int:
        s = sorted(str(num))
        return int('',join(s[::2])) + int(''.join(s[1::2]))
```

#### 253. Meeting Rooms II
Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the
minimum number of conference rooms required.

Example:
Input: intervals = [[0,30],[5,10],[15,20]]
Output: 2

Constraints:
0 <= intervals.length <= 10^4
intervals[i].length == 2
0 <= starti < endi <= 10^6

```
class Solution:
    def minMeetingRooms(self, intervasl: List[List[int]]) -> int:
        intervals.sort()
        hq = []
        res = 0
        for start, end in intervals:
            while hq and hq[0] <= start:
                heapq.heappop(hq)
            heapq.heappush(hq, end)
            res = max(res, len(hq))
        return res
```

#### 1353. Maximum Number of Events That Can Be Attended
You are given an array of events where events[i] = [startDayi, endDayi]. Every event i starts at
startDayi and ends at endDayi.
You can attend an event i at any day d where startTimei <= d <= endTimei. You can only attend
one event at any time d.
Return the maximum number of events you can attend.
Example:
Input: events = [[1,2],[2,3],[3,4]]
Output: 3
Explanation: You can attend all the three events.
One way to attend them all is as shown.
Attend the first event on day 1.
Attend the second event on day 2.
Attend the third event on day 3.
