# Binary Search
- find a target on sorted list
- always find the mid point and split
- time complexity: O(log n)

Types of questions summary:
## 1. Find the target in sorted array
```
def search(self, nums: List[int], target: int) -> int:
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            return mid
        if nums[mid] < target:
            start = mid + 1
        else:
            end = mid - 1
    return -1
```
## 2. Find first and last position of element in sorted array
Given an array of integers nums sorted in non-
decreasing order, find the starting and ending

position of a given target value.

Input: nums = [5,7,7,8,8,10], target = 8
Output: [3,4]
```
# approach 1
def findFirst(self, nums, target):
    start = 0
    end = len(nums) - 1
    while start <= end:
        mid = (start + end)//2
        if nums[mid] == target:
            if mid == 0 or nums[mid] != nums[mid - 1]:
                return mid
            end = mid - 1
        elif nums[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return -1
# approach 2
def findLast(self, nums, target):
    start = 0
    end = len(nums) - 1
    answer = -1
    while start <= end:
        mid = (start + end) // 2
        if nums[mid] == target:
            answer = mid
            start = mid + 1
        elif nums[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return answer
```
#### 74. Search a 2D Matrix
Write an efficient algorithm that searches for a
value target in an m x n integer matrix matrix. This
matrix has the following properties:
•Integers in each row are sorted from left to right.
•The first integer of each row is greater than the last
integer of the previous row.

#### Follow up: 240. Search a 2D Matrix 2
Write an efficient algorithm that searches for a
value target in an m x n integer matrix matrix. This
matrix has the following properties:
•Integers in each row are sorted in ascending from
left to right.
•Integers in each column are sorted in ascending
from top to bottom.

## 3. binary search on special arrays
special arrays:
1. rotated sorted array
2. find peak
#### 154. Find Minimum in rotated sorted array 2
code logic:
If nums[mid] > numbs[end], min is at left of the mid, so left = mid + 1.
If nums[mid] < numbs[end], min is either mid or at the right of the mid, so right = mid.
If nums[mid] == numbs[end], we dont know, right = right - 1.

#### 33. Search in Rotated Sorted Array
Given the array nums (with distinct values) after the
possible rotation and an integer target, return the index of
target if it is in nums, or -1 if it is not in nums.
1. find mid
2. nums[mid] vs target
3. check [left, mid - 1] or [mid + 1, right] is sorted
4. ...

#### 162. Find Peak Element
A peak element is an element that is strictly greater than its neighbors.
Given a 0-indexed integer array nums(for any i, nums[i] != nums[i + 1]), find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.
You may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.

Example:
Input: nums = [1,2,3,1] Output: 2

code logic:
if nums[0] >= nums[i], then peak index is i - 1.
```
class Solution:
    def findPeakElement(self, nums: List[int]) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = (left + right) // 2
            if self.get(nums, mid - 1) < nums[mid] > self.get(nums, mid + 1):
              return mid
            if self.get(nums, mid - 1) < nums[mid]:
              left = mid + 1
            else: 
              right = mid - 1
    def get(self, nums, idx):
        if 0 <= idx < len(nums):
            return nums[idx]
        return -float("inf")
```
#### 1901. Find Peak Element 2
A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom.
Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j].
You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell.

Find max per row or col, and check which of those max is the peak.
https://courses.csail.mit.edu/6.006/spring11/lectures/lec02.pdf 

```
class Solution:
    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:
        n, m = len(mat), len(mat[0])
        start = 0
        end = n - 1
        while (start <= end):
            mid = (start + end) // 2
            maxVal = max(mat[mid])
            maxIdx = mat[mid].index(maxVal)
            if (mid == 0 or mat[mid][maxIdx] > mat[mid - 1][maxIdx]) and (mid == n - 1 or mat[mid][maxIdx] > mat[mid + 1][maxIdx]):
                return [mid, maxIdx]
            if mid > 0 and mat[mid][maxIdx] < mat[mid - 1][maxIdx]:
                end = mid - 1
            else:
                start = mid + 1
```
